1) Перед установкой нужно дать права в настройках Докерана чтение с диска на котором находится файл init.sql

2) Установка PostgreSQL:

docker-compose rm -f
docker-compose up --build

3) Запуск пректа:

Зайти в папку test_project
выполнить "gradle bootrun"

4) Запуск нагрузочного теста

gradle gatlingRun-quotePerfTest.QuotePerfTestPerHour2 --rerun-tasks

Комментарий к задаче:

При решении использовал: Spring Boot, JpaRepository, modelmapper (для перекидывания данных между Dto и Entity), gatling для нагрузочного тестирования.

Получился обычный Rest-интерфейс + база данных. Для двух несвязных таблиц нет необходимости делать каких либо запросов на SQL, оптимизация через
JdbcTemplate была бы бессмысслена.

Разработка велась методом TDD. Два набора тестов: BadTests для ошибок и отрицательных сценариев, GoodTest для положительных сценариев и
примера работы из задания. AbstractBaseTest содержит общий код для обоих тестов.

При записи в таблицу quotes_energy_level первоначально я исапользовал @Transactional(isolation = Isolation.SERIALIZABLE) + кастомный метод
для JpaRepository(можно посмотреть в файле QuotesEnergyLevelRepositoryWithLock.java; код не используется, но я оставил для примера). И всё
было хорошо до нагрузочного тестирования. Выяснилось что при нагрузке более 30 одновременных попыток изменения записи начинает ругаться PostgreSQL.
Возможно есть настройка, но я решил дальше не искать. В результате сославшись на логику что чтение, обработки и записи значения
должен выполнять один процесс я использовал synchronized. Не лучшее решение. Но во-первых, это (почти) соответствует логике, исключение
в том что PostgreSQL должен был блокировать запись, а synchronized по-факту блокирует таблицу. Во-вторых, 100 запросов в секунду так же 
отрабатывают.

Пример отчёта от gatling'а можно посмотреть в папке report